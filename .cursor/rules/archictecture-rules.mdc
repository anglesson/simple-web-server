---
alwaysApply: true
---


# Project Structure
The main server setup and entry point is defined in cmd/web/main.go

## SSR Handlers
- All SSR handlers are defined in internal/handler/

## Services
- All services are defined in internal/service/

## Repositories
- All repositories are defined in internal/repository/

## UI - DashUI Template
- All html pages are defined in web/pages
- All templates email are defined in web/mails
- All layouts are defined in web/layouts
- All assets are defined in web/assets
- **Template**: DashUI - Bootstrap 5 Admin Dashboard Template
- **CSS**: theme.min.css (DashUI custom styles)
- **JS**: theme.min.js (DashUI custom scripts)
- **Icons**: Feather Icons (data-feather attribute)
- **Components**: Cards, Tables, Forms, Modals, Dropdowns

## External Services
- Located in pkg/

## Libraries
- GORM: All models are localized in internal/models/
- SQLite: When running local
- Postgres: When running in production
- **Frontend**: DashUI (Bootstrap 5 + Custom Components)
- **Icons**: Feather Icons
- **JavaScript**: Vanilla JS + Bootstrap 5 JS

## Tests
- The test are included in same path of implementation and you package has a sufix '_test' in package name. Exemple: If package is 'cookie', the test will be in 'cookie_test'
- To run tests use the command `make test`
- Always include tests for each feature or problem encountered or modifications

## Server
- To start web server use the command `make run`

## Rules
- Always use clear, descriptive, and meaningful names for variables, functions, and methods, following Clean Code recommendations to facilitate code readability and maintainability.
- Implement code adhering to S.O.L.I.D principles, ensuring high cohesion, low coupling, and easy extensibility and maintainability.
- Always use the good practices of dependency injection
- Never use emoji in code

# Architecture Rules

## Handler Construction Rule

### Localização
- Todos os handlers devem ser definidos no diretório `internal/handler/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_handler.go` (ex: `client_handler.go`).
- O nome da struct principal do handler deve ser `<Feature>Handler` (ex: `ClientHandler`).

### Estrutura
- O handler deve ser implementado como uma struct, utilizando injeção de dependências para serviços necessários.
- O construtor do handler deve ser uma função `New<Feature>Handler`, recebendo explicitamente as dependências.
- Métodos do handler devem ser funções públicas (iniciando com maiúscula) e receber o contexto do framework web (ex: `echo.Context`, `gin.Context`, etc).

### Responsabilidade
- O handler deve ser responsável apenas por:
  - Receber e validar requisições HTTP.
  - Chamar os serviços apropriados.
  - Retornar respostas HTTP.
  - Renderizar templates DashUI com dados apropriados.
- Não deve conter lógica de negócio, que deve estar nos serviços.

### DashUI Integration
- **Template Rendering**: Usar `template.View(w, r, "page", data, "admin")` para páginas administrativas
- **Data Structure**: Dados devem ser passados como `map[string]any` e acessados via `.Data.Variavel` no template
- **Flash Messages**: Implementar mensagens de feedback usando `web.FlashMessageFactory`
- **Pagination**: Usar `models.Pagination` para listagens com paginação
- **Search/Filter**: Implementar busca e filtros para melhorar UX

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `CreateClient`, `UpdateClient`).
- Validar e tratar erros de forma consistente, retornando respostas HTTP adequadas.
- Utilizar middlewares para autenticação, autorização e logging, evitando lógica repetida nos handlers.
- Sempre incluir testes para cada handler, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/handler/client_handler.go

type ClientHandler struct {
    clientService service.ClientService
}

func NewClientHandler(clientService service.ClientService) *ClientHandler {
    return &ClientHandler{clientService: clientService}
}

func (h *ClientHandler) CreateClient(c echo.Context) error {
    // Validação, chamada de serviço, resposta
}
```

## Repository Construction Rule

### Localização
- Todos os repositories devem ser definidos no diretório `internal/repository/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_repository.go` (ex: `client_repository.go`).
- O nome da interface principal do repository deve ser `<Feature>Repository` (ex: `ClientRepository`).
- O nome da struct de implementação deve ser `<feature>RepositoryImpl` (ex: `clientRepositoryImpl`).

### Estrutura
- O repository deve ser implementado como uma interface, definindo os métodos públicos para acesso e manipulação de dados.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para o acesso ao banco de dados (ex: *gorm.DB).
- O construtor do repository deve ser uma função `New<Feature>Repository`, recebendo explicitamente as dependências e retornando a interface do repository.
- Métodos do repository devem ser funções públicas (iniciando com maiúscula).

### Responsabilidade
- O repository deve ser responsável apenas por:
  - Realizar operações de acesso a dados (CRUD) e consultas específicas.
  - Mapear entidades do domínio para o banco de dados e vice-versa.
  - Implementar consultas otimizadas para listagens e dashboards.
- Não deve conter lógica de negócio (deve ser feita nos services).
- Não deve conter lógica de apresentação ou manipulação de HTTP.

### DashUI Query Optimization
- **Pagination Support**: Implementar queries com `LIMIT` e `OFFSET` para paginação eficiente
- **Search Queries**: Criar consultas otimizadas para busca em múltiplos campos
- **Filter Support**: Implementar filtros dinâmicos para diferentes critérios
- **Count Queries**: Separar queries de contagem para paginação precisa
- **Eager Loading**: Usar `Preload` para carregar relacionamentos necessários
- **Index Optimization**: Garantir que queries frequentes tenham índices adequados

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `Create`, `FindByID`, `Update`, `Delete`).
- Validar e tratar erros de forma consistente, retornando erros claros para os services.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada repository, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/repository/client_repository.go

type ClientRepository interface {
    Create(client *models.Client) error
    FindByID(id int) (*models.Client, error)
    Update(client *models.Client) error
    Delete(id int) error
}

type clientRepositoryImpl struct {
    db *gorm.DB
}

func NewClientRepository(db *gorm.DB) ClientRepository {
    return &clientRepositoryImpl{db: db}
}

func (r *clientRepositoryImpl) Create(client *models.Client) error {
    // Operação de inserção no banco de dados
}
```

## Service Construction Rule

### Localização
- Todos os services devem ser definidos no diretório `internal/service/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_service.go` (ex: `client_service.go`).
- O nome da interface principal do service deve ser `<Feature>Service` (ex: `ClientService`).
- O nome da struct de implementação deve ser `<feature>ServiceImpl` (ex: `clientServiceImpl`).

### Estrutura
- O service deve ser implementado como uma interface, definindo os métodos públicos que representam as operações de negócio.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para repositórios e outros serviços necessários.
- O construtor do service deve ser uma função `New<Feature>Service`, recebendo explicitamente as dependências e retornando a interface do service.
- Métodos do service devem ser funções públicas (iniciando com maiúscula).

### Responsabilidade
- O service deve ser responsável apenas por:
  - Conter a lógica de negócio da aplicação.
  - Orquestrar chamadas a repositórios e outros serviços.
  - Garantir regras de negócio e validações complexas.
  - Preparar dados para apresentação no DashUI.
- Não deve conter lógica de acesso a dados diretamente (deve delegar aos repositórios).
- Não deve conter lógica de apresentação ou manipulação de HTTP (deve ser feito nos handlers).

### DashUI Data Preparation
- **Model Methods**: Implementar métodos nos models para formatação de dados (ex: `GetInitials()`, `GetFormattedDate()`)
- **Data Transformation**: Transformar dados do banco para formato adequado ao template
- **Pagination Support**: Retornar dados paginados para listagens
- **Search/Filter Logic**: Implementar lógica de busca e filtros
- **Status Management**: Gerenciar estados e status para badges e indicadores visuais

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `CreateClient`, `UpdateClient`).
- Validar e tratar erros de forma consistente, retornando erros claros para os handlers.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada service, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/service/client_service.go

type ClientService interface {
    CreateClient(input CreateClientInput) (Client, error)
    UpdateClient(id int, input UpdateClientInput) (Client, error)
}

type clientServiceImpl struct {
    clientRepo repository.ClientRepository
}

func NewClientService(clientRepo repository.ClientRepository) ClientService {
    return &clientServiceImpl{clientRepo: clientRepo}
}

func (s *clientServiceImpl) CreateClient(input CreateClientInput) (Client, error) {
    // Lógica de negócio, chamada ao repositório, validação
}
```

## Refactoring Rule

### Obrigatoriedade de Refatoração
- **Qualquer componente que não esteja no padrão adequado descrito nas regras acima DEVE ser refatorado caso haja modificação no mesmo.**
- **Não é permitido adicionar novas funcionalidades ou fazer modificações em handlers, services ou repositories que não sigam os padrões estabelecidos.**
- **A refatoração deve ser feita ANTES de qualquer modificação funcional.**

### Processo de Refatoração
1. **Identificação**: Identificar se o componente segue os padrões da arquitetura
2. **Refatoração**: Aplicar os padrões corretos (struct, injeção de dependências, interfaces)
3. **Testes**: Garantir que os testes existentes continuem funcionando
4. **Modificação**: Apenas após a refatoração, realizar as modificações funcionais desejadas

### Exemplos de Componentes que Precisam de Refatoração
- Handlers implementados como funções globais em vez de structs
- Services sem interfaces ou sem injeção de dependências
- Repositories sem interfaces ou com acesso direto ao banco
- Qualquer componente que misture responsabilidades (ex: lógica de negócio em handlers)

### Benefícios da Refatoração
- **Testabilidade**: Facilita a criação de mocks e testes unitários
- **Manutenibilidade**: Código mais limpo e organizado
- **Extensibilidade**: Facilita a adição de novas funcionalidades
- **Consistência**: Mantém a arquitetura uniforme em todo o projeto

- Always use the good practices of dependency injection
- Never use emoji in code

# Project Structure
The main server setup and entry point is defined in cmd/web/main.go

## SSR Handlers
- All SSR handlers are defined in internal/handler/

## Services
- All services are defined in internal/service/

## Repositories
- All repositories are defined in internal/repository/

## UI - DashUI Template
- All html pages are defined in web/pages
- All templates email are defined in web/mails
- All layouts are defined in web/layouts
- All assets are defined in web/assets
- **Template**: DashUI - Bootstrap 5 Admin Dashboard Template
- **CSS**: theme.min.css (DashUI custom styles)
- **JS**: theme.min.js (DashUI custom scripts)
- **Icons**: Feather Icons (data-feather attribute)
- **Components**: Cards, Tables, Forms, Modals, Dropdowns

## External Services
- Located in pkg/

## Libraries
- GORM: All models are localized in internal/models/
- SQLite: When running local
- Postgres: When running in production
- **Frontend**: DashUI (Bootstrap 5 + Custom Components)
- **Icons**: Feather Icons
- **JavaScript**: Vanilla JS + Bootstrap 5 JS

## Tests
- The test are included in same path of implementation and you package has a sufix '_test' in package name. Exemple: If package is 'cookie', the test will be in 'cookie_test'
- To run tests use the command `make test`
- Always include tests for each feature or problem encountered or modifications

## Server
- To start web server use the command `make run`

## Rules
- Always use clear, descriptive, and meaningful names for variables, functions, and methods, following Clean Code recommendations to facilitate code readability and maintainability.
- Implement code adhering to S.O.L.I.D principles, ensuring high cohesion, low coupling, and easy extensibility and maintainability.
- Always use the good practices of dependency injection
- Never use emoji in code

# Architecture Rules

## Handler Construction Rule

### Localização
- Todos os handlers devem ser definidos no diretório `internal/handler/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_handler.go` (ex: `client_handler.go`).
- O nome da struct principal do handler deve ser `<Feature>Handler` (ex: `ClientHandler`).

### Estrutura
- O handler deve ser implementado como uma struct, utilizando injeção de dependências para serviços necessários.
- O construtor do handler deve ser uma função `New<Feature>Handler`, recebendo explicitamente as dependências.
- Métodos do handler devem ser funções públicas (iniciando com maiúscula) e receber o contexto do framework web (ex: `echo.Context`, `gin.Context`, etc).

### Responsabilidade
- O handler deve ser responsável apenas por:
  - Receber e validar requisições HTTP.
  - Chamar os serviços apropriados.
  - Retornar respostas HTTP.
  - Renderizar templates DashUI com dados apropriados.
- Não deve conter lógica de negócio, que deve estar nos serviços.

### DashUI Integration
- **Template Rendering**: Usar `template.View(w, r, "page", data, "admin")` para páginas administrativas
- **Data Structure**: Dados devem ser passados como `map[string]any` e acessados via `.Data.Variavel` no template
- **Flash Messages**: Implementar mensagens de feedback usando `web.FlashMessageFactory`
- **Pagination**: Usar `models.Pagination` para listagens com paginação
- **Search/Filter**: Implementar busca e filtros para melhorar UX

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `CreateClient`, `UpdateClient`).
- Validar e tratar erros de forma consistente, retornando respostas HTTP adequadas.
- Utilizar middlewares para autenticação, autorização e logging, evitando lógica repetida nos handlers.
- Sempre incluir testes para cada handler, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/handler/client_handler.go

type ClientHandler struct {
    clientService service.ClientService
}

func NewClientHandler(clientService service.ClientService) *ClientHandler {
    return &ClientHandler{clientService: clientService}
}

func (h *ClientHandler) CreateClient(c echo.Context) error {
    // Validação, chamada de serviço, resposta
}
```

## Repository Construction Rule

### Localização
- Todos os repositories devem ser definidos no diretório `internal/repository/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_repository.go` (ex: `client_repository.go`).
- O nome da interface principal do repository deve ser `<Feature>Repository` (ex: `ClientRepository`).
- O nome da struct de implementação deve ser `<feature>RepositoryImpl` (ex: `clientRepositoryImpl`).

### Estrutura
- O repository deve ser implementado como uma interface, definindo os métodos públicos para acesso e manipulação de dados.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para o acesso ao banco de dados (ex: *gorm.DB).
- O construtor do repository deve ser uma função `New<Feature>Repository`, recebendo explicitamente as dependências e retornando a interface do repository.
- Métodos do repository devem ser funções públicas (iniciando com maiúscula).

### Responsabilidade
- O repository deve ser responsável apenas por:
  - Realizar operações de acesso a dados (CRUD) e consultas específicas.
  - Mapear entidades do domínio para o banco de dados e vice-versa.
  - Implementar consultas otimizadas para listagens e dashboards.
- Não deve conter lógica de negócio (deve ser feita nos services).
- Não deve conter lógica de apresentação ou manipulação de HTTP.

### DashUI Query Optimization
- **Pagination Support**: Implementar queries com `LIMIT` e `OFFSET` para paginação eficiente
- **Search Queries**: Criar consultas otimizadas para busca em múltiplos campos
- **Filter Support**: Implementar filtros dinâmicos para diferentes critérios
- **Count Queries**: Separar queries de contagem para paginação precisa
- **Eager Loading**: Usar `Preload` para carregar relacionamentos necessários
- **Index Optimization**: Garantir que queries frequentes tenham índices adequados

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `Create`, `FindByID`, `Update`, `Delete`).
- Validar e tratar erros de forma consistente, retornando erros claros para os services.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada repository, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/repository/client_repository.go

type ClientRepository interface {
    Create(client *models.Client) error
    FindByID(id int) (*models.Client, error)
    Update(client *models.Client) error
    Delete(id int) error
}

type clientRepositoryImpl struct {
    db *gorm.DB
}

func NewClientRepository(db *gorm.DB) ClientRepository {
    return &clientRepositoryImpl{db: db}
}

func (r *clientRepositoryImpl) Create(client *models.Client) error {
    // Operação de inserção no banco de dados
}
```

## Service Construction Rule

### Localização
- Todos os services devem ser definidos no diretório `internal/service/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_service.go` (ex: `client_service.go`).
- O nome da interface principal do service deve ser `<Feature>Service` (ex: `ClientService`).
- O nome da struct de implementação deve ser `<feature>ServiceImpl` (ex: `clientServiceImpl`).

### Estrutura
- O service deve ser implementado como uma interface, definindo os métodos públicos que representam as operações de negócio.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para repositórios e outros serviços necessários.
- O construtor do service deve ser uma função `New<Feature>Service`, recebendo explicitamente as dependências e retornando a interface do service.
- Métodos do service devem ser funções públicas (iniciando com maiúscula).

### Responsabilidade
- O service deve ser responsável apenas por:
  - Conter a lógica de negócio da aplicação.
  - Orquestrar chamadas a repositórios e outros serviços.
  - Garantir regras de negócio e validações complexas.
  - Preparar dados para apresentação no DashUI.
- Não deve conter lógica de acesso a dados diretamente (deve delegar aos repositórios).
- Não deve conter lógica de apresentação ou manipulação de HTTP (deve ser feito nos handlers).

### DashUI Data Preparation
- **Model Methods**: Implementar métodos nos models para formatação de dados (ex: `GetInitials()`, `GetFormattedDate()`)
- **Data Transformation**: Transformar dados do banco para formato adequado ao template
- **Pagination Support**: Retornar dados paginados para listagens
- **Search/Filter Logic**: Implementar lógica de busca e filtros
- **Status Management**: Gerenciar estados e status para badges e indicadores visuais

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `CreateClient`, `UpdateClient`).
- Validar e tratar erros de forma consistente, retornando erros claros para os handlers.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada service, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/service/client_service.go

type ClientService interface {
    CreateClient(input CreateClientInput) (Client, error)
    UpdateClient(id int, input UpdateClientInput) (Client, error)
}

type clientServiceImpl struct {
    clientRepo repository.ClientRepository
}

func NewClientService(clientRepo repository.ClientRepository) ClientService {
    return &clientServiceImpl{clientRepo: clientRepo}
}

func (s *clientServiceImpl) CreateClient(input CreateClientInput) (Client, error) {
    // Lógica de negócio, chamada ao repositório, validação
}
```

## Refactoring Rule

### Obrigatoriedade de Refatoração
- **Qualquer componente que não esteja no padrão adequado descrito nas regras acima DEVE ser refatorado caso haja modificação no mesmo.**
- **Não é permitido adicionar novas funcionalidades ou fazer modificações em handlers, services ou repositories que não sigam os padrões estabelecidos.**
- **A refatoração deve ser feita ANTES de qualquer modificação funcional.**

### Processo de Refatoração
1. **Identificação**: Identificar se o componente segue os padrões da arquitetura
2. **Refatoração**: Aplicar os padrões corretos (struct, injeção de dependências, interfaces)
3. **Testes**: Garantir que os testes existentes continuem funcionando
4. **Modificação**: Apenas após a refatoração, realizar as modificações funcionais desejadas

### Exemplos de Componentes que Precisam de Refatoração
- Handlers implementados como funções globais em vez de structs
- Services sem interfaces ou sem injeção de dependências
- Repositories sem interfaces ou com acesso direto ao banco
- Qualquer componente que misture responsabilidades (ex: lógica de negócio em handlers)

### Benefícios da Refatoração
- **Testabilidade**: Facilita a criação de mocks e testes unitários
- **Manutenibilidade**: Código mais limpo e organizado
- **Extensibilidade**: Facilita a adição de novas funcionalidades
- **Consistência**: Mantém a arquitetura uniforme em todo o projeto

- Always use the good practices of dependency injection
- Never use emoji in code
