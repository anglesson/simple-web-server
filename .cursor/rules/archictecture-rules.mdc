

# Project Structure
The main server setup and entry point is defined in cmd/web/main.go

## Modular Architecture (NEW)
The application is being refactored to use a modular architecture where each feature is self-contained within its own module.

### Module Structure
Each module should be located in `internal/<module_name>/` and contain:
- `handler.go` - HTTP handlers for the module
- `service.go` - Business logic services for the module  
- `repository.go` - Data access interfaces for the module
- `models.go` - Module-specific models and Module struct
- `routes.go` - Route registration for the module

### Module Example (Client Module)
```
internal/client/
├── handler.go      # ClientHandler struct with HTTP methods
├── service.go      # ClientService interface and implementation
├── repository.go   # ClientRepository interface
├── models.go       # Module struct and module-specific types
└── routes.go       # Route registration with middleware
```

## Legacy Structure (DEPRECATED - Being Refactored)
The following structure is being phased out in favor of the modular approach:

### SSR Handlers
- All SSR handlers are defined in internal/handler/

### Services
- All services are defined in internal/service/

### Repositories
- All repositories are defined in internal/repository/

## UI - DashUI Template
- All html pages are defined in web/pages
- All templates email are defined in web/mails
- All layouts are defined in web/layouts
- All assets are defined in web/assets
- **Template**: DashUI - Bootstrap 5 Admin Dashboard Template
- **CSS**: theme.min.css (DashUI custom styles)
- **JS**: theme.min.js (DashUI custom scripts)
- **Icons**: FontAwesome Icons (preferred over Feather Icons)
- **Components**: Cards, Tables, Forms, Modals, Dropdowns

## External Services
- Located in pkg/

## Libraries
- GORM: All models are localized in internal/models/
- SQLite: When running local
- Postgres: When running in production
- **Frontend**: DashUI (Bootstrap 5 + Custom Components)
- **Icons**: FontAwesome Icons
- **JavaScript**: Vanilla JS + Bootstrap 5 JS

## Tests
- The test are included in same path of implementation and you package has a sufix '_test' in package name. Exemple: If package is 'cookie', the test will be in 'cookie_test'
- To run tests use the command `make test`
- Always include tests for each feature or problem encountered or modifications

## Server
- To start web server use the command `make run`

## Rules
- Always use clear, descriptive, and meaningful names for variables, functions, and methods, following Clean Code recommendations to facilitate code readability and maintainability.
- Implement code adhering to S.O.L.I.D principles, ensuring high cohesion, low coupling, and easy extensibility and maintainability.
- Always use the good practices of dependency injection
- Never use emoji in code

# Architecture Rules

## Module Construction Rule (NEW - PREFERRED)

### Localização
- Todos os módulos devem ser definidos no diretório `internal/<module_name>/`.
- Cada módulo deve ser um package Go separado e independente.

### Estrutura do Módulo
Cada módulo deve conter os seguintes arquivos:

#### `handler.go`
- Implementar struct `<Feature>Handler` com injeção de dependências
- Construtor `New<Feature>Handler` recebendo todas as dependências necessárias
- Métodos HTTP públicos seguindo padrão REST

#### `service.go`
- Interface `<Feature>Service` definindo operações de negócio
- Implementação `featureServiceImpl` com injeção de dependências
- Construtor `New<Feature>Service` recebendo repositories e outros serviços

#### `repository.go`
- Interface `<Feature>Repository` para operações de dados
- Implementação concreta em `internal/repository/gorm/` ou similar
- Métodos para CRUD e consultas específicas do domínio

#### `models.go`
- Struct `Module` centralizando todas as dependências do módulo
- Tipos específicos do módulo (ex: `ClientFilter`)
- Exemplo:
```go
type Module struct {
    Handler    *ClientHandler
    Service    service.ClientService
    Repository repository.ClientRepository
}
```

#### `routes.go`
- Função `RegisterRoutes` para registrar rotas do módulo
- Aplicar middlewares necessários (auth, trial, subscription)
- Agrupar rotas relacionadas ao domínio

### Responsabilidade
- **Handler**: Receber requisições HTTP, validar, chamar serviços, renderizar templates
- **Service**: Lógica de negócio, validações, orquestração de repositories
- **Repository**: Acesso a dados, queries otimizadas, mapeamento de entidades
- **Module**: Centralizar e gerenciar dependências do módulo

### DashUI Integration
- **Template Rendering**: Usar `templateRenderer.View()` para renderização
- **Flash Messages**: Implementar usando `web.FlashMessageFactory`
- **Data Structure**: Dados como `map[string]interface{}` para templates
- **Pagination**: Suporte a `models.Pagination` para listagens

### Exemplo de Módulo Completo
```go
// internal/client/models.go
type Module struct {
    Handler    *ClientHandler
    Service    service.ClientService
    Repository repository.ClientRepository
}

// internal/client/handler.go
type ClientHandler struct {
    clientService       service.ClientService
    creatorService      service.CreatorService
    flashMessageFactory web.FlashMessageFactory
    templateRenderer    template.TemplateRenderer
}

// internal/client/routes.go
func RegisterRoutes(r chi.Router, handler *ClientHandler, authMiddleware, trialMiddleware, subscriptionMiddleware func(next http.Handler) http.Handler) {
    r.Group(func(r chi.Router) {
        r.Use(authMiddleware)
        r.Use(trialMiddleware)
        r.Use(subscriptionMiddleware)
        
        r.Get("/client", handler.ClientIndexView)
        r.Post("/client", handler.ClientCreateSubmit)
        // ... outras rotas
    })
}
```

## Registro do Módulo no App Principal

### Estrutura do App
O módulo deve ser registrado no `internal/app.go` para centralizar todas as dependências da aplicação:

```go
// internal/app.go
type App struct {
    ClientModule *client.Module
    // Outros módulos serão adicionados aqui
    // EbookModule  *ebook.Module
    // FileModule   *file.Module
    // etc...
}

// NewApp cria uma nova instância da aplicação com todos os módulos
func NewApp(templateRenderer template.TemplateRenderer, flashMessageFactory web.FlashMessageFactory) *App {
    // Inicializar repositórios
    clientRepository := gorm.NewClientGormRepository()
    creatorRepository := gorm.NewCreatorRepository(database.DB)
    
    // Inicializar serviços externos
    commonRFService := gov.NewHubDevService()
    
    // Inicializar módulo client
    clientService := service.NewClientService(clientRepository, creatorRepository, commonRFService)
    creatorService := service.NewCreatorService(creatorRepository, commonRFService, nil, nil, nil)
    clientHandler := client.NewClientHandler(clientService, creatorService, flashMessageFactory, templateRenderer)
    
    clientModule := &client.Module{
        Handler:    clientHandler,
        Service:    clientService,
        Repository: clientRepository,
    }
    
    return &App{
        ClientModule: clientModule,
    }
}

// Métodos de acesso aos módulos
func (app *App) GetClientHandler() *client.ClientHandler {
    return app.ClientModule.Handler
}

func (app *App) GetClientService() service.ClientService {
    return app.ClientModule.Service.(service.ClientService)
}
```

### Uso no Main
No `cmd/web/main.go`, o módulo é acessado através do App:

```go
func main() {
    // Criar appModule com todos os módulos
    appModule := internal.NewApp(templateRenderer, flashServiceFactory)
    
    // Usar o handler do módulo client através do appModule
    clientHandler := appModule.GetClientHandler()
    
    // Registrar rotas do módulo
    client.RegisterRoutes(r, clientHandler, 
        middleware.AuthMiddleware, 
        middleware.TrialMiddleware, 
        middleware.SubscriptionMiddleware(subscriptionService))
}
```

### Benefícios do Registro Centralizado
- **Dependency Injection**: Todas as dependências são injetadas no App
- **Lifecycle Management**: Controle centralizado do ciclo de vida dos módulos
- **Testing**: Facilita a criação de mocks e testes de integração
- **Configuration**: Configuração centralizada de todos os módulos
- **Scalability**: Fácil adição de novos módulos sem modificar o main

## Handler Construction Rule (LEGACY - Being Refactored)

### Localização
- Todos os handlers devem ser definidos no diretório `internal/handler/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_handler.go` (ex: `client_handler.go`).
- O nome da struct principal do handler deve ser `<Feature>Handler` (ex: `ClientHandler`).

### Estrutura
- O handler deve ser implementado como uma struct, utilizando injeção de dependências para serviços necessários.
- O construtor do handler deve ser uma função `New<Feature>Handler`, recebendo explicitamente as dependências.
- Métodos do handler devem ser funções públicas (iniciando com maiúscula) e receber o contexto do framework web (ex: `echo.Context`, `gin.Context`, etc).

### Responsabilidade
- O handler deve ser responsável apenas por:
  - Receber e validar requisições HTTP.
  - Chamar os serviços apropriados.
  - Retornar respostas HTTP.
  - Renderizar templates DashUI com dados apropriados.
- Não deve conter lógica de negócio, que deve estar nos serviços.

### DashUI Integration
- **Template Rendering**: Usar `template.View(w, r, "page", data, "admin")` para páginas administrativas
- **Data Structure**: Dados devem ser passados como `map[string]any` e acessados diretamente via `.Variavel` no template
- **Flash Messages**: Implementar mensagens de feedback usando `web.FlashMessageFactory`
- **Pagination**: Usar `models.Pagination` para listagens com paginação
- **Search/Filter**: Implementar busca e filtros para melhorar UX

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `CreateClient`, `UpdateClient`).
- Validar e tratar erros de forma consistente, retornando respostas HTTP adequadas.
- Utilizar middlewares para autenticação, autorização e logging, evitando lógica repetida nos handlers.
- Sempre incluir testes para cada handler, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/handler/client_handler.go

type ClientHandler struct {
    clientService service.ClientService
}

func NewClientHandler(clientService service.ClientService) *ClientHandler {
    return &ClientHandler{clientService: clientService}
}

func (h *ClientHandler) CreateClient(c echo.Context) error {
    // Validação, chamada de serviço, resposta
}
```

## Repository Construction Rule (LEGACY - Being Refactored)

### Localização
- Todos os repositories devem ser definidos no diretório `internal/repository/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_repository.go` (ex: `client_repository.go`).
- O nome da interface principal do repository deve ser `<Feature>Repository` (ex: `ClientRepository`).
- O nome da struct de implementação deve ser `<feature>RepositoryImpl` (ex: `clientRepositoryImpl`).

### Estrutura
- O repository deve ser implementado como uma interface, definindo os métodos públicos para acesso e manipulação de dados.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para o acesso ao banco de dados (ex: *gorm.DB).
- O construtor do repository deve ser uma função `New<Feature>Repository`, recebendo explicitamente as dependências e retornando a interface do repository.
- Métodos do repository devem ser funções públicas (iniciando com maiúscula).

### Responsabilidade
- O repository deve ser responsável apenas por:
  - Realizar operações de acesso a dados (CRUD) e consultas específicas.
  - Mapear entidades do domínio para o banco de dados e vice-versa.
  - Implementar consultas otimizadas para listagens e dashboards.
- Não deve conter lógica de negócio (deve ser feita nos services).
- Não deve conter lógica de apresentação ou manipulação de HTTP.

### DashUI Query Optimization
- **Pagination Support**: Implementar queries com `LIMIT` e `OFFSET` para paginação eficiente
- **Search Queries**: Criar consultas otimizadas para busca em múltiplos campos
- **Filter Support**: Implementar filtros dinâmicos para diferentes critérios
- **Count Queries**: Separar queries de contagem para paginação precisa
- **Eager Loading**: Usar `Preload` para carregar relacionamentos necessários
- **Index Optimization**: Garantir que queries frequentes tenham índices adequados

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `Create`, `FindByID`, `Update`, `Delete`).
- Validar e tratar erros de forma consistente, retornando erros claros para os services.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada repository, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/repository/client_repository.go

type ClientRepository interface {
    Create(client *models.Client) error
    FindByID(id int) (*models.Client, error)
    Update(client *models.Client) error
    Delete(id int) error
}

type clientRepositoryImpl struct {
    db *gorm.DB
}

func NewClientRepository(db *gorm.DB) ClientRepository {
    return &clientRepositoryImpl{db: db}
}

func (r *clientRepositoryImpl) Create(client *models.Client) error {
    // Operação de inserção no banco de dados
}
```

## Service Construction Rule (LEGACY - Being Refactored)

### Localização
- Todos os services devem ser definidos no diretório `internal/service/`.

### Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_service.go` (ex: `client_service.go`).
- O nome da interface principal do service deve ser `<Feature>Service` (ex: `ClientService`).
- O nome da struct de implementação deve ser `<feature>ServiceImpl` (ex: `clientServiceImpl`).

### Estrutura
- O service deve ser implementado como uma interface, definindo os métodos públicos que representam as operações de negócio.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para repositórios e outros serviços necessários.
- O construtor do service deve ser uma função `New<Feature>Service`, recebendo explicitamente as dependências e retornando a interface do service.
- Métodos do service devem ser funções públicas (iniciando com maiúscula).

### Responsabilidade
- O service deve ser responsável apenas por:
  - Conter a lógica de negócio da aplicação.
  - Orquestrar chamadas a repositórios e outros serviços.
  - Garantir regras de negócio e validações complexas.
  - Preparar dados para apresentação no DashUI.
- Não deve conter lógica de acesso a dados diretamente (deve delegar aos repositórios).
- Não deve conter lógica de apresentação ou manipulação de HTTP (deve ser feito nos handlers).

### DashUI Data Preparation
- **Model Methods**: Implementar métodos nos models para formatação de dados (ex: `GetInitials()`, `GetFormattedDate()`)
- **Data Transformation**: Transformar dados do banco para formato adequado ao template
- **Pagination Support**: Retornar dados paginados para listagens
- **Search/Filter Logic**: Implementar lógica de busca e filtros
- **Status Management**: Gerenciar estados e status para badges e indicadores visuais

### Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `CreateClient`, `UpdateClient`).
- Validar e tratar erros de forma consistente, retornando erros claros para os handlers.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada service, cobrindo casos de sucesso e falha.

### Exemplo de estrutura mínima

```go
// internal/service/client_service.go

type ClientService interface {
    CreateClient(input CreateClientInput) (Client, error)
    UpdateClient(id int, input UpdateClientInput) (Client, error)
}

type clientServiceImpl struct {
    clientRepo repository.ClientRepository
}

func NewClientService(clientRepo repository.ClientRepository) ClientService {
    return &clientServiceImpl{clientRepo: clientRepo}
}

func (s *clientServiceImpl) CreateClient(input CreateClientInput) (Client, error) {
    // Lógica de negócio, chamada ao repositório, validação
}
```

## Migration Strategy (NEW)

### Prioridade de Migração
1. **Novos módulos**: Sempre usar a arquitetura modular
2. **Módulos existentes**: Migrar quando houver modificações
3. **Módulos legados**: Manter funcionando até migração completa

### Processo de Migração
1. **Criar estrutura modular** em `internal/<module_name>/`
2. **Implementar funcionalidades** seguindo padrões modulares
3. **Migrar rotas** para o novo sistema
4. **Atualizar main.go** para usar novos módulos
5. **Remover código legado** após validação completa

### Benefícios da Modularização
- **Coesão**: Cada módulo é responsável por seu domínio
- **Manutenibilidade**: Código organizado e fácil de entender
- **Testabilidade**: Testes isolados por módulo
- **Escalabilidade**: Fácil adicionar novos módulos
- **Dependências**: Gerenciamento claro de dependências

## Refactoring Rule

### Obrigatoriedade de Refatoração
- **Qualquer componente que não esteja no padrão adequado descrito nas regras acima DEVE ser refatorado caso haja modificação no mesmo.**
- **Não é permitido adicionar novas funcionalidades ou fazer modificações em handlers, services ou repositories que não sigam os padrões estabelecidos.**
- **A refatoração deve ser feita ANTES de qualquer modificação funcional.**

### Processo de Refatoração
1. **Identificação**: Identificar se o componente segue os padrões da arquitetura
2. **Refatoração**: Aplicar os padrões corretos (struct, injeção de dependências, interfaces)
3. **Testes**: Garantir que os testes existentes continuem funcionando
4. **Modificação**: Apenas após a refatoração, realizar as modificações funcionais desejadas

### Exemplos de Componentes que Precisam de Refatoração
- Handlers implementados como funções globais em vez de structs
- Services sem interfaces ou sem injeção de dependências
- Repositories sem interfaces ou com acesso direto ao banco
- Qualquer componente que misture responsabilidades (ex: lógica de negócio em handlers)

### Benefícios da Refatoração
- **Testabilidade**: Facilita a criação de mocks e testes unitários
- **Manutenibilidade**: Código mais limpo e organizado
- **Extensibilidade**: Facilita a adição de novas funcionalidades
- **Consistência**: Mantém a arquitetura uniforme em todo o projeto

## General Rules
- Always use the good practices of dependency injection
- Never use emoji in code
- Prefer FontAwesome icons over Feather icons
- Ensure all tests pass before delivering code
- Use `rm -rf ./cmd/web/web` to remove the built web server binary
